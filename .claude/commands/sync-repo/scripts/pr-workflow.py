#!/usr/bin/env python3
"""
PR creation workflow for documentation sync.

Handles:
- Checking for existing PRs to avoid duplicates
- Creating branches with standardized naming
- Committing documentation changes
- Pushing to remote
- Creating PRs via gh CLI
"""

import json
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional


def run_command(cmd: List[str], cwd: Optional[Path] = None, check: bool = False) -> subprocess.CompletedProcess:
    """Run a command and return the result."""
    result = subprocess.run(
        cmd,
        cwd=cwd,
        capture_output=True,
        text=True,
        check=False
    )
    if check and result.returncode != 0:
        print(f"Command failed: {' '.join(cmd)}", file=sys.stderr)
        print(f"stderr: {result.stderr}", file=sys.stderr)
        raise subprocess.CalledProcessError(result.returncode, cmd)
    return result


def get_branch_name(date: Optional[str] = None) -> str:
    """Generate a standardized branch name for doc sync PRs."""
    if date is None:
        date = datetime.now().strftime("%Y-%m-%d")
    return f"chore/doc-sync-{date}"


def get_pr_title() -> str:
    """Generate the PR title."""
    date = datetime.now().strftime("%Y-%m-%d")
    return f"docs: Update documentation ({date})"


def get_pr_body(repo_name: str, changes: List[str]) -> str:
    """Generate the PR body."""
    changes_list = "\n".join(f"- {c}" for c in changes) if changes else "- Documentation updates"

    return f"""# Documentation Update

This PR updates documentation for **{repo_name}** as part of the automated AstraBit documentation sync.

## Changes

{changes_list}

## Files Modified

- `catalog-info.yaml` - Service catalog metadata
- `README.md` - Repository documentation
- `INTEGRATIONS.md` - Cross-repository integration points

## Generated by

This PR was created automatically by the AstraBit documentation sync workflow.

---

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
"""


def check_existing_pr(repo_name: str, org: str, branch_name: str) -> Optional[Dict[str, Any]]:
    """
    Check if there's an existing open PR for this repo from the doc sync workflow.

    Returns the PR info if found, None otherwise.
    """
    result = run_command([
        "gh", "pr", "list",
        "--repo", f"{org}/{repo_name}",
        "--state", "open",
        "--head", branch_name,
        "--json", "number,title,url,createdAt"
    ])

    if result.returncode != 0:
        return None

    try:
        prs = json.loads(result.stdout)
        if prs:
            return prs[0]  # Return the first (and should be only) matching PR
    except json.JSONDecodeError:
        pass

    return None


def has_uncommitted_changes(repo_path: Path) -> bool:
    """Check if there are uncommitted changes in the repo."""
    result = run_command(["git", "status", "--porcelain"], cwd=repo_path)
    return bool(result.stdout.strip())




def create_branch(repo_path: Path, branch_name: str, default_branch: str = "main") -> bool:
    """Create and checkout a new branch from the default branch.

    CRITICAL WORKFLOW - ensures PR only contains doc commit:
    1. Fetch latest from remote
    2. Checkout default branch (develop/main)
    3. Pull latest changes
    4. Create and checkout new branch from current HEAD
    """
    run_command(["git", "fetch", "origin"], cwd=repo_path)
    
    # Checkout default branch
    result = run_command(["git", "checkout", default_branch], cwd=repo_path)
    if result.returncode != 0:
        result = run_command(["git", "checkout", f"origin/{default_branch}", "-b", default_branch], cwd=repo_path)
        if result.returncode != 0:
            return False
    
    # Pull latest changes
    run_command(["git", "pull", "origin", default_branch], cwd=repo_path)
    
    # Create new branch
    result = run_command(["git", "checkout", "-b", branch_name], cwd=repo_path)
    return result.returncode == 0


def commit_changes(repo_path: Path, files: List[str], message: str) -> bool:
    """Stage and commit the specified files."""
    # Add files
    for file in files:
        file_path = repo_path / file
        if file_path.exists():
            run_command(["git", "add", str(file_path)], cwd=repo_path)

    # Check if there's anything to commit
    result = run_command(["git", "diff", "--cached", "--quiet"], cwd=repo_path)

    # diff --cached returns 0 if no changes, 1 if there are changes
    if result.returncode == 0:
        return False  # Nothing to commit

    # Commit
    result = run_command(["git", "commit", "-m", message], cwd=repo_path)
    return result.returncode == 0


def push_branch(repo_path: Path, branch_name: str) -> bool:
    """Push the branch to remote."""
    result = run_command([
        "git", "push",
        "--set-upstream", "origin", branch_name
    ], cwd=repo_path)
    return result.returncode == 0


def create_pr(repo_name: str, org: str, branch_name: str,
              title: str, body: str, default_branch: str = "main") -> Optional[Dict[str, Any]]:
    """Create a PR using gh CLI."""
    result = run_command([
        "gh", "pr", "create",
        "--repo", f"{org}/{repo_name}",
        "--base", default_branch,
        "--head", branch_name,
        "--title", title,
        "--body", body,
        "--label", "documentation",
        "--label", "automated"
    ])

    if result.returncode != 0:
        print(f"  Failed to create PR: {result.stderr}", file=sys.stderr)
        return None

    # Extract PR URL from output
    pr_url = result.stdout.strip()
    return {"url": pr_url}


class PRWorkflow:
    """Main workflow for creating PRs with documentation updates."""

    def __init__(self, org: str, repos_dir: Path, default_branch: str = "main"):
        self.org = org
        self.repos_dir = repos_dir
        self.default_branch = default_branch
        self.branch_name = get_branch_name()
        self.pr_title = get_pr_title()
        self.date = datetime.now().strftime("%Y-%m-%d")

    def process_repo(self, repo_name: str,
                     changes: List[str],
                     files_to_commit: List[str],
                     dry_run: bool = False) -> Dict[str, Any]:
        """
        Process a single repository through the full PR workflow.

        Args:
            repo_name: Name of the repository
            changes: List of change descriptions for the PR body
            files_to_commit: List of files to commit (e.g., ["catalog-info.yaml", "README.md"])
            dry_run: If True, don't actually create PR

        Returns:
            Dict with status and PR info
        """
        result = {
            "repo": repo_name,
            "status": "unknown",
            "pr": None,
            "existing_pr": None,
        }

        repo_path = self.repos_dir / repo_name

        # 1. Check for existing PR
        existing_pr = check_existing_pr(repo_name, self.org, self.branch_name)
        if existing_pr:
            result["status"] = "skipped"
            result["existing_pr"] = existing_pr
            return result

        # 2. Check if there are changes to commit
        if not has_uncommitted_changes(repo_path):
            result["status"] = "no_changes"
            return result

        if dry_run:
            result["status"] = "dry_run"
            result["pr"] = {"url": f"https://github.com/{self.org}/{repo_name}/pull/dry-run"}
            return result

        # 3. Create branch
        if not create_branch(repo_path, self.branch_name, self.default_branch):
            result["status"] = "failed"
            result["error"] = "Failed to create branch"
            return result

        # 4. Commit changes
        if not commit_changes(repo_path, files_to_commit, self.pr_title):
            result["status"] = "failed"
            result["error"] = "Failed to commit changes"
            return result

        # 5. Push branch
        if not push_branch(repo_path, self.branch_name):
            result["status"] = "failed"
            result["error"] = "Failed to push branch"
            return result

        # 6. Create PR
        pr_body = get_pr_body(repo_name, changes)
        pr_info = create_pr(repo_name, self.org, self.branch_name,
                           self.pr_title, pr_body, self.default_branch)

        if pr_info:
            result["status"] = "created"
            result["pr"] = pr_info
        else:
            result["status"] = "failed"
            result["error"] = "Failed to create PR"

        return result


def main():
    """CLI for testing PR workflow."""
    import argparse

    parser = argparse.ArgumentParser(description="Test PR workflow")
    parser.add_argument("repo", help="Repository name")
    parser.add_argument("--org", default="Astrabit-CPT", help="GitHub organization")
    parser.add_argument("--repos-dir", default="repos", help="Local repos directory")
    parser.add_argument("--dry-run", action="store_true", help="Dry run")
    args = parser.parse_args()

    workflow = PRWorkflow(args.org, Path(args.repos_dir))

    # Check existing PR
    existing = check_existing_pr(args.repo, args.org, workflow.branch_name)
    if existing:
        print(f"Existing PR found: #{existing['number']} - {existing['title']}")
        print(f"  URL: {existing['url']}")
        print(f"  Created: {existing['createdAt']}")
        return

    print(f"Branch name: {workflow.branch_name}")
    print(f"PR title: {workflow.pr_title}")

    if args.dry_run:
        print("Dry run mode - no changes will be made")
    else:
        print("Would create PR now (use --dry-run to test)")

    # Test repo processing
    result = workflow.process_repo(
        args.repo,
        changes=["Updated catalog-info.yaml", "Added README.md"],
        files_to_commit=["catalog-info.yaml", "README.md"],
        dry_run=args.dry_run
    )

    print(f"\nResult: {result}")


if __name__ == "__main__":
    main()
