#!/usr/bin/env python3
"""
Process a single repository: generate docs and create a PR.

This script is called by sync-all.py for each repository that needs updates.
It generates catalog-info.yaml, creates a branch, commits, pushes, and creates a PR.

Usage: python process-repo-pr.py <repo_name> <repos_dir> <org> <branch_name>
"""

import json
import subprocess
import sys
from pathlib import Path


def run_cmd(cmd, cwd=None):
    """Run command and return result."""
    result = subprocess.run(
        cmd,
        cwd=cwd,
        capture_output=True,
        text=True,
        check=False
    )
    return result


def main():
    if len(sys.argv) < 5:
        print("Usage: process-repo-pr.py <repo_name> <repos_dir> <org> <branch_name>", file=sys.stderr)
        return 1

    repo_name = sys.argv[1]
    repos_dir = Path(sys.argv[2])
    org = sys.argv[3]
    branch_name = sys.argv[4]

    repo_path = repos_dir / repo_name

    if not repo_path.exists():
        print(f"Error: Repo path {repo_path} does not exist", file=sys.stderr)
        return 1

    # Step 1: Generate catalog-info.yaml
    print(f"[{repo_name}] Generating catalog-info.yaml...", flush=True)

    metadata_script = Path(__file__).parent.parent.parent.parent / "skills" / "repo-metadata" / "scripts" / "generate-metadata.py"

    result = run_cmd(["py", str(metadata_script), str(repo_path)])
    if result.returncode != 0:
        print(f"[{repo_name}] Warning: Metadata generation failed: {result.stderr}", flush=True)
        # Continue anyway - we'll try to create a basic file

    catalog_content = result.stdout

    # Write catalog-info.yaml
    catalog_path = repo_path / "catalog-info.yaml"
    original_content = None
    if catalog_path.exists():
        original_content = catalog_path.read_text()

    catalog_path.write_text(catalog_content)

    # Step 2: Check if there are changes
    result = run_cmd(["git", "status", "--porcelain"], cwd=repo_path)
    if not result.stdout.strip():
        print(f"[{repo_name}] No changes to commit", flush=True)
        return 0

    # Step 3: Get default branch
    result = run_cmd(["git", "symbolic-ref", "refs/remotes/origin/HEAD"], cwd=repo_path)
    if result.returncode == 0:
        default_branch = result.stdout.strip().split("/")[-1]
    else:
        default_branch = "main"  # fallback

    # Step 4: Create branch
    print(f"[{repo_name}] Creating branch {branch_name}...", flush=True)
    result = run_cmd(["git", "checkout", "-b", branch_name], cwd=repo_path)
    if result.returncode != 0:
        # Reset and try again
        run_cmd(["git", "reset", "--hard", f"origin/{default_branch}"], cwd=repo_path)
        run_cmd(["git", "checkout", "-b", branch_name], cwd=repo_path)

    # Step 5: Commit changes
    print(f"[{repo_name}] Committing changes...", flush=True)
    run_cmd(["git", "add", "catalog-info.yaml"], cwd=repo_path)
    run_cmd(["git", "commit", "-m", f"docs: Update documentation ({branch_name})"], cwd=repo_path)

    # Step 6: Push branch
    print(f"[{repo_name}] Pushing to remote...", flush=True)
    result = run_cmd(["git", "push", "-u", "origin", branch_name], cwd=repo_path)
    if result.returncode != 0:
        print(f"[{repo_name}] Error: Push failed: {result.stderr}", flush=True)
        return 1

    # Step 7: Create PR
    print(f"[{repo_name}] Creating PR...", flush=True)

    pr_body = f"""# Documentation Update

This PR updates documentation for **{repo_name}** as part of the automated AstraBit documentation sync.

## Changes

- Added/updated `catalog-info.yaml` - Service catalog metadata

## Generated by

This PR was created automatically by the AstraBit documentation sync workflow.

---

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
"""

    result = run_cmd([
        "gh", "pr", "create",
        "--repo", f"{org}/{repo_name}",
        "--base", default_branch,
        "--head", branch_name,
        "--title", f"docs: Update documentation ({branch_name})",
        "--body", pr_body
    ])

    if result.returncode != 0:
        print(f"[{repo_name}] Error: PR creation failed: {result.stderr}", flush=True)
        return 1

    pr_url = result.stdout.strip()
    print(f"[{repo_name}] PR created: {pr_url}", flush=True)

    # Output JSON result for parsing
    print(f"__RESULT__:{{\"repo\": \"{repo_name}\", \"pr_url\": \"{pr_url}\"}}", flush=True)

    return 0


if __name__ == "__main__":
    sys.exit(main())
